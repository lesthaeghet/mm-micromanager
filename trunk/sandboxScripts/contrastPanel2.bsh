import org.micromanager.acquisition.*;
import org.micromanager.graph.*;
import ij.*;


	Color getChannelColor(CompositeImage image, int channel) {
		cm = image.getLuts()[channel-1];
		if (cm==null)
			return Color.black;
		int index = cm.getMapSize() - 1;
		int r = cm.getRed(index);
		int g = cm.getGreen(index);
		int b = cm.getBlue(index);
		//IJ.log(index+" "+r+" "+g+" "+b);
		if (r<100 || g<100 || b<100)
			return new Color(r, g, b);
		else
			return Color.black;
	}


getChannelColors(CompositeImage image) {
	int nChannels = image.getNChannels();
	chanColors = new Color[nChannels];
	for (int i=0;i<nChannels;++i) {
		chanColors[i] = getChannelColor(image, i+1);
	}
	return chanColors;
}


update();

mv = MetadataViewer.singletonViewer_;
sp = mv.jScrollPane1;
p = new JPanel();
hpHeight = 90;
image = IJ.getImage();
nChannels = image.getNChannels();
chanColors = getChannelColors(image);
p.setPreferredSize(new Dimension(700,nChannels * hpHeight));
sp.setViewportView(p);
p.setLayout(null);

for (int i=0;i<nChannels;++i) {
hp = new HistogramPanel();
hp.setMargins(8,8);
hp.setTraceStyle(true, chanColors[i]);
hp.setTextVisible(false);
hp.setGridVisible(false);


int[] rawHistogram = image.getStack().getProcessor(i+1).getHistogram();
    if (rawHistogram != null) {
       histogramData_ = new GraphData();
    } // 256 bins

         int[] histogram = new int[256];
			binSize_ = 1;
         int limit = Math.min(rawHistogram.length / binSize_, 256);
         int total = 0;
         for (int i = 0; i < limit; i++) {
            histogram[i] = 0;
            for (int j = 0; j < binSize_; j++) {
               histogram[i] += rawHistogram[i * binSize_ + j];
            }
            total += histogram[i];
         }
         // work around what is apparently a bug in ImageJ
         if (total == 0) {
            if (image.getProcessor().getMin() == 0) {
               histogram[0] = image.getWidth() * image.getHeight();
            } else {
               histogram[limit - 1] = image.getWidth() * image.getHeight();
            }
         }
         if (false) {
            for (int i = 0; i < histogram.length; i++) {
               histogram[i] = histogram[i] > 0 ? (int) (1000 * Math.log(histogram[i])) : 0;
            }
         }
	histogramData_.setData(histogram);
   hp.setGamma(1.0);
	hp.setData(histogramData_);
	hp.setAutoBounds(); // Call this after setting data.
	hp.setCursors(0,255,1.0);
hp.setBounds(0,hpHeight*i,200,hpHeight-5);
p.add(hp);
hp.repaint();
}
