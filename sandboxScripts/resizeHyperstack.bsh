import ij.*;
import ij.process.*;


/*
Arthur - 1/13/2011
So far, this works for a single position and single channel,
with one or more slices and one or more frames.
There are still problems when we include channels
and positions.
*/


nChannels = 2;
nSlices = 4;
nFrames = 1;
imgp = IJ.getImage();
stack = imgp.getStack();
win = imgp.getWindow();

// Package private:
cs = win.cSelector;
zs = win.zSelector;
ts = win.tSelector;

// An instance of my AcquisitionVirtualStack:
stack.setSize(nChannels * nSlices * nFrames); // my stack
	
// Protected:
imgp.nChannels = nChannels;
imgp.nSlices = nSlices;
imgp.nFrames = nFrames;

// Package private:
win.nChannels = nChannels;
win.nSlices = nSlices;
win.nFrames = nFrames;
/*
if (nChannels > 1) {
	cip = new ImageProcessor[nChannels];
	for (int i = 0;i<imgp.cip.length; ++i) {
      cip[i] = imgp.cip[i];
   }
	for (int i = imgp.cip.length; i<nChannels; ++i) {
      cip[i] = imgp.cip[imgp.cip.length - 1];
	}
	imgp.cip = cip;
	lut = new LUT[nChannels];
	for (int i = 0;i<imgp.lut.length; ++i) {
      lut[i] = imgp.lut[i];
   }
	for (int i = imgp.lut.length; i<nChannels; ++i) {
      lut[i] = imgp.lut[imgp.lut.length - 1];
	}
	imgp.lut = lut;

}
	*/
// Public:
if (win.hyperStack) {
   if (cs != null)
		cs.setMaximum(nChannels + 1);
   if (zs != null)
		zs.setMaximum(nSlices + 1);
   if (ts != null)
		ts.setMaximum(nFrames + 1);
} else {
	if (zs != null)
		zs.setMaximum(stack.getSize() + 1);
}

// cip, lut

