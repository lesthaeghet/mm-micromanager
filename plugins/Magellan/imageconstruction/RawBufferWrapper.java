/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package imageconstruction;

import org.micromanager.MMStudio;

/**
 * Class that wraps raw, double wide, warped buffer to support fast access
 * without having to actually access anything
 * @author henrypinkard
 */
public class RawBufferWrapper {
   
   //set in Bitflow camera file or other A/D converter
   private static final int PIXELS_PER_LINE = 1288;
   private static final int MAX_FRAME_OFFSET = 128;

   
   private int processedHeight_, processedWidth_;
   private static int[] warpedIndicesFromUnwarped_;
   
   private byte[] buffer_;
   private int offset_;
   private static int unwarpedWidth_;
   
   public RawBufferWrapper(byte[] buffer, int offset, int doubleWidth) {
      if (warpedIndicesFromUnwarped_ == null) {
         warpedIndicesFromUnwarped_ = getCosineWarpLUT(PIXELS_PER_LINE);
         unwarpedWidth_ = warpedIndicesFromUnwarped_.length;
      }
      
      offset_ = offset;
      buffer_ = buffer;
   }
   
   public short getUnwarpedImageValue(int x, int y) {
      int warpedX = warpedIndicesFromUnwarped_[x];
      //TODO: reverse if on second half of image to account for image
      //channelPtr = const_cast<unsigned char*>(buf) + i*bufLen + BFCamera::MAX_FRAME_OFFSET + GetChannelOffset(i);
      int warpedIndex = warpedX + y * (PIXELS_PER_LINE / 2);
      return (short) (buffer_[warpedIndex] & 0xff);
   }
   
   public static int getWidth() {
      if (warpedIndicesFromUnwarped_ == null) {
         warpedIndicesFromUnwarped_ = getCosineWarpLUT(PIXELS_PER_LINE);
         unwarpedWidth_ = warpedIndicesFromUnwarped_.length;
      }
      return unwarpedWidth_;
   }
   
   public static int getHeight() {
      //twice the raw image height
      return (int) (MMStudio.getInstance().getCore().getImageHeight() * 2);
   }
   
   /**
    * This function assumes an interlaced, but still warped image its
    * purpose is to generate a pixel LUT with unwarped pixel indices and 
    * warped pixel values
    * Function assumes that number of pixels per line is equal to number of pixels
    * in the double wide image (i.e. no pixels thrown away at start and end of line)
    * 1288 pixels per line to get 410 pixels per image
    */
   public static int[] getCosineWarpLUT(int pixPerLine) {
      int lineStartThrowawayPixels = 0;
      int interlacedWidth = pixPerLine / 2;
      //each pixel corresponds to the same amount of time, but a different amount of space
      //at the very center of the image, there will be a 1-to-1 correpondance of warped
      //pixels and unwarped pixels, at the edges, there will be several unwarped pixels
      //for each warped one
      double radiansPerPix = 2 * Math.PI / (double) pixPerLine;

      int[] unwarpedFromWarped = new int[pixPerLine / 2];

      //find center pixel, i.e. the pixel where distortion is minimized, and 1 pixel
      //in warped image corresponds to one pixel in unwarped image
      //this LUT generated by this function operates on images that have already been deinterlaced.
      //Assuming the offset is correct, the pixelPerLine will start at phase 0 and end at 2pi
      //so the center pixel should be at pi/2
      int centerPixel = pixPerLine / 4 - lineStartThrowawayPixels;
      int lutOffset = -1; //used to 0 base indices since theyre calculated form image center
      double[] warpedPixPerPix = new double[interlacedWidth];
      for (int warpedPixIndex = 0; warpedPixIndex < interlacedWidth; warpedPixIndex++) {
         double angle = ((warpedPixIndex+0.5) + lineStartThrowawayPixels) * radiansPerPix; //add 0.5 to calculate from center of image
         //represents the relative speed of the mirror at this pixel position
         double relativeSpeedOfMirror = Math.cos(angle - Math.PI / 2);
         //so the inverse of speed is the number of warped pixels per a single pixel in the unwarped image
         warpedPixPerPix[warpedPixIndex] = 1 / relativeSpeedOfMirror;
//         System.out.println(warpedPixPerPix[warpedPixIndex]);
         //correction factor = angular displacemnt / cos(angular displacement - pi/2)
         double displacement = angle - Math.PI/2;
         double correctionFactor = displacement / Math.cos(displacement - Math.PI / 2);
         
//         System.out.println((warpedPixIndex - centerPixel) + "\t" + ((warpedPixIndex - centerPixel) /correctionFactor));
         //make sure lutValues start at 0
         int lutValue = centerPixel + (int)((warpedPixIndex - centerPixel) /correctionFactor); 
         if (lutOffset == -1) {
            lutOffset = lutValue;
         }
         lutValue -= lutOffset;
//         System.out.println( lutValue );
         unwarpedFromWarped[warpedPixIndex] = lutValue;
      }
      //now invert the indices and values of LUT
      
      int[] warpedFromUnwarped = new int[unwarpedFromWarped[unwarpedFromWarped.length-1]+1];
      for (int i = 0; i < warpedFromUnwarped.length; i++) {
         warpedFromUnwarped[i] = getCenterIndexOf(unwarpedFromWarped, i);     
      }
      
      return warpedFromUnwarped;
  }
   
   /**
    * @param array
    * @param val
    * @return the middle index of val in a sorted array with one or more occurrence of val
    */
   public static int getCenterIndexOf(int[] array, int val) {
      int first = -1;
      int last = -1;
      for (int i = 0; i < array.length; i++) {
         if (array[i] == val && first == -1) {
            first = i;
         }
         if (array[i] == val) {
            last = i;
         }
      }
      return (first + last) / 2;
   }
   
}
