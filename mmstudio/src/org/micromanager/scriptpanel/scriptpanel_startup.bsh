// BeanShell startup script for Micro-Manager.
// This script runs when the beanshell interpreter is started in the Scripting Panel
// Arthur Edelstein, UCSF, 2009


class dummyClassToForceBeanshellToUseAHashtableInItsNamespaceMethodsList {;} 

setAccessibility(true);


////
//// Load Documentation
////

import bsh.ClassIdentifier;
import ij.plugin.BrowserLauncher;



getClassName(bsh.ClassIdentifier o) {
	return getClassName(o,this.caller.namespace);
}

getClassName(Object o) {
	return getClassName(o,this.caller.namespace);
}

getClassName(bsh.ClassIdentifier o, namespace) {
	return namespace.identifierToClass(o).getName();
}

getClassName(Object o, namespace) {
	if (o instanceof String)
		return namespace.getClass((String) o).getName();
	else if (o instanceof Class)
		return o.getName();
	else
		return o.getClass().getName();
}

doc(bsh.ClassIdentifier o) {
	className = getClassName(o,this.caller.namespace);
	doc_className(className);
}

doc(Object o) {
	className = getClassName(o,this.caller.namespace);
	doc_className(className);
}

doc_className(String className) {
	print(className);
	String [] sunAPIpkgs = {"java","javax","org.ietf","org.omg","org.w3c","org.xml"};

	boolean sunAPI = false;
	boolean ijAPI = false;
	for (sunAPIpkg : sunAPIpkgs) {
		sunAPI = sunAPI || className.startsWith(sunAPIpkg + ".");
		}
	
	suffix = className.replace(".","/") + ".html";

	theUrl = null;
	if (sunAPI)	
		theUrl = "http://java.sun.com/javase/6/docs/api/" + suffix;
	if (className.startsWith("ij.")) // ImageJ API
		theUrl = "http://rsb.info.nih.gov/ij/developer/api/" + suffix;
	if (className.startsWith("bsh.")) // Beanshell API
		theUrl = "http://odelacot.homelinux.org/doc/bsh-doc/api/" + suffix;
	if (className.startsWith("org.micromanager")) // Micro-Manager API
		theUrl = "http://micro-manager.org/content/doc/mmstudio/" + suffix;
	if (className.startsWith("mmcorej.CMMCore"))
		theUrl = "http://micro-manager.org/content/doc/CMMCore.html";
	if (className.startsWith("org.jdesktop.swingx"))
		theUrl = "http://download.java.net/javadesktop/swinglabs/releases/0.8/docs/api/index.html?" + suffix;

	if (theUrl!=null)
		BrowserLauncher.openURL(theUrl);
	else
		print("No docs found.");
}


////
//// Object inspector
////

inspect(obj) {
   object_ = obj;
   frame_ = new javax.swing.JFrame();
   methodsModel_ = new javax.swing.table.DefaultTableModel();
   fieldsModel_ = new javax.swing.table.DefaultTableModel();

   void makeUI() {
      tabbedPane = new javax.swing.JTabbedPane();

      methodsTable = new org.jdesktop.swingx.JXTable();
      methodsTable.setModel(methodsModel_);
      tabbedPane.addTab("Methods", new javax.swing.JScrollPane(methodsTable));

      fieldsTable = new org.jdesktop.swingx.JXTable();
      fieldsTable.setModel(fieldsModel_);
      tabbedPane.addTab("Fields", new javax.swing.JScrollPane(fieldsTable));

      frame_.add(tabbedPane);
      frame_.pack();
      frame_.setBounds(100, 100, 900, 700);
      frame_.show();
   }

   void update() {
      // If we add a "Refresh" button, it would be nice to preserve the JXTable
      // sorting and column reordring. This is not currently done.
      methodsModel_.setDataVector(getMethodsData(object_), getMethodsCols());
      fieldsModel_.setDataVector(getFieldsData(object_), getFieldsCols());
   }

   Vector getMethodsCols() {
      cols = new Vector();
      cols.add("Name");
      cols.add("Return Type");
      cols.add("Parameter Types");
      cols.add("Declared in");
      return cols;
   }

   Vector getMethodRow(obj, cls, method) {
      sb = new StringBuilder();
      for (paramType : method.getParameterTypes()) {
         if (sb.length() > 0) {
            sb.append(", ");
         }
         sb.append(paramType);
      }
      paramTypes = sb.toString();

      row = new Vector();
      row.add(method.getName());
      row.add(method.getReturnType());
      row.add(paramTypes);
      row.add(cls.getName());
      return row;
   }

   Vector getMethodsData(obj) {
      rows = new Vector();
      for (cls = obj.getClass(); cls != null; cls = cls.getSuperclass()) {
         methods = cls.getDeclaredMethods();
         for (method : methods) {
            // TODO We do not currently hide or provide any indication of
            // overridden methods in superclasses.
            rows.add(getMethodRow(obj, cls, method));
         }
      }
      return rows;
   }

   Vector getFieldsCols() {
      cols = new Vector();
      cols.add("Name");
      cols.add("Value");
      cols.add("Type");
      cols.add("Declared in");
      return cols;
   }

   Vector getFieldRow(obj, cls, field) {
      v = eval("obj." + field.getName());
      value = (v != null ? v.toString() : "null");

      row = new Vector();
      row.add(field.getName());
      row.add(value);
      row.add(field.getType());
      row.add(cls.getName());
      return row;
   }

   Vector getFieldsData(obj) {
      rows = new Vector();
      for (cls = obj.getClass(); cls != null; cls = cls.getSuperclass()) {
         fields = cls.getDeclaredFields();
         for (field : fields) {
            rows.add(getFieldRow(obj, cls, field));
         }
      }
      return rows;
   }

   print("Starting inspector...");
   update();
   makeUI();

   // Although not normally needed, it might be handy for testing if we return
   // this object.
   return this;
}
