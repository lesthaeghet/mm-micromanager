// ScriptPanel BeanShell startup script for Micro-Manager.
//
// Authors: Arthur Edelstein, 2009; Mark Tsuchida, 2014.
//
// Copyright (c) 2009-2014 University of California, San Francisco
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//   * Redistributions of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//   * Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//   * Neither the name of the University of California nor the names of its
//     contributors may be used to endorse or promote products derived from
//     this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.


class dummyClassToForceBeanshellToUseAHashtableInItsNamespaceMethodsList {}

setAccessibility(false);


////
//// Load Documentation
////

import bsh.ClassIdentifier;
import ij.plugin.BrowserLauncher;



getClassName(bsh.ClassIdentifier o) {
	return getClassName(o,this.caller.namespace);
}

getClassName(Object o) {
	return getClassName(o,this.caller.namespace);
}

getClassName(bsh.ClassIdentifier o, namespace) {
	return namespace.identifierToClass(o).getName();
}

getClassName(Object o, namespace) {
	if (o instanceof String)
		return namespace.getClass((String) o).getName();
	else if (o instanceof Class)
		return o.getName();
	else
		return o.getClass().getName();
}

doc(bsh.ClassIdentifier o) {
	className = getClassName(o,this.caller.namespace);
	doc_className(className);
}

doc(Object o) {
	className = getClassName(o,this.caller.namespace);
	doc_className(className);
}

doc_className(String className) {
	print(className);
	String [] sunAPIpkgs = {"java","javax","org.ietf","org.omg","org.w3c","org.xml"};

	boolean sunAPI = false;
	boolean ijAPI = false;
	for (sunAPIpkg : sunAPIpkgs) {
		sunAPI = sunAPI || className.startsWith(sunAPIpkg + ".");
		}
	
	suffix = className.replace(".","/") + ".html";

	theUrl = null;
	if (sunAPI)	
		theUrl = "http://docs.oracle.com/javase/6/docs/api/" + suffix;
	if (className.startsWith("ij."))
		theUrl = "http://rsb.info.nih.gov/ij/developer/api/" + suffix;
	if (className.startsWith("bsh."))
		theUrl = "http://www.beanshell.org/javadoc/" + suffix;
	if (className.startsWith("org.micromanager."))
		theUrl = "http://valelab.ucsf.edu/~MM/doc/mmstudio/" + suffix;
	if (className.startsWith("mmcorej."))
		theUrl = "http://valelab.ucsf.edu/~MM/doc/mmcorej/" + suffix;
	if (className.startsWith("org.jdesktop.swingx."))
		theUrl = "http://download.java.net/javadesktop/swinglabs/releases/0.8/docs/api/" + suffix;

	if (theUrl!=null)
		BrowserLauncher.openURL(theUrl);
	else
		print("No docs found.");
}


////
//// Object inspector
////

inspect(obj) {
   object_ = obj;
   frame_ = new javax.swing.JFrame("Inspector for instance of class " +
         object_.getClass().getName());
   methodsModel_ = new javax.swing.table.DefaultTableModel();
   fieldsModel_ = new javax.swing.table.DefaultTableModel();

   void makeUI() {
      tabbedPane = new javax.swing.JTabbedPane();

      methodsTable = new org.jdesktop.swingx.JXTable();
      methodsTable.setModel(methodsModel_);
      tabbedPane.addTab("Methods", new javax.swing.JScrollPane(methodsTable));

      fieldsTable = new org.jdesktop.swingx.JXTable();
      fieldsTable.setModel(fieldsModel_);
      tabbedPane.addTab("Fields", new javax.swing.JScrollPane(fieldsTable));

      frame_.add(tabbedPane);
      frame_.pack();
      frame_.setBounds(100, 100, 900, 700);
      frame_.show();
   }

   void update() {
      // If we add a "Refresh" button, it would be nice to preserve the JXTable
      // sorting and column reordring. This is not currently done.
      methodsModel_.setDataVector(getMethodsData(object_), getMethodsCols());
      fieldsModel_.setDataVector(getFieldsData(object_), getFieldsCols());
   }

   Vector getMethodsCols() {
      cols = new Vector();
      cols.add("Name");
      cols.add("Return Type");
      cols.add("Parameter Types");
      cols.add("Declared in");
      return cols;
   }

   Vector getMethodRow(obj, cls, method) {
      sb = new StringBuilder();
      for (paramType : method.getParameterTypes()) {
         if (sb.length() > 0) {
            sb.append(", ");
         }
         sb.append(paramType);
      }
      paramTypes = sb.toString();

      row = new Vector();
      row.add(method.getName());
      row.add(method.getReturnType());
      row.add(paramTypes);
      row.add(cls.getName());
      return row;
   }

   Vector getMethodsData(obj) {
      rows = new Vector();
      for (cls = obj.getClass(); cls != null; cls = cls.getSuperclass()) {
         methods = cls.getDeclaredMethods();
         for (method : methods) {
            // TODO We do not currently hide or provide any indication of
            // overridden methods in superclasses.
            rows.add(getMethodRow(obj, cls, method));
         }
      }
      return rows;
   }

   Vector getFieldsCols() {
      cols = new Vector();
      cols.add("Name");
      cols.add("Value");
      cols.add("Type");
      cols.add("Declared in");
      return cols;
   }

   Vector getFieldRow(obj, cls, field) {
      try {
         v = eval("obj." + field.getName());
         value = (v != null ? v.toString() : "null");
      }
      catch (Exception e) {
         value = "<inaccessible>";
      }

      row = new Vector();
      row.add(field.getName());
      row.add(value);
      row.add(field.getType());
      row.add(cls.getName());
      return row;
   }

   Vector getFieldsData(obj) {
      rows = new Vector();
      for (cls = obj.getClass(); cls != null; cls = cls.getSuperclass()) {
         fields = cls.getDeclaredFields();
         for (field : fields) {
            rows.add(getFieldRow(obj, cls, field));
         }
      }
      return rows;
   }

   print("Starting inspector...");
   update();
   makeUI();

   // Although not normally needed, it might be handy for testing if we return
   // this object.
   return this;
}
